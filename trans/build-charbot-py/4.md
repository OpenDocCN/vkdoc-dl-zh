# 4.艰难地构建聊天机器人

“艰难地构建聊天机器人”并不难学。完全控制你自己的聊天机器人是构建聊天机器人的艰难方式。如果你想自己做所有的事情，那么你会选择困难的路线。更难的路，当你走过的时候是艰难的，但当你回头看的时候却是美丽而清晰的。

> 这是一条通向伟大顶峰的崎岖之路。
> 
> ——卢修斯·安纳乌斯·塞内卡

如果你很了解 Python，并且对如何设置包有一点了解，等等。，学习这一章不会有任何问题。如果你是开发者，对你来说应该很容易。如果你是一个管理人员或者非技术人员，你仍然可以像每个部分提到的那样一个一个地做步骤，把事情做好。我强烈建议每个人都完成这一章，这样你就能学到关于构建聊天机器人的核心知识。

本章不仅教你从零开始构建聊天机器人，还向你展示了核心机器学习(ML)如何在拉莎·NLU 的帮助下与 NLP 一起工作。正如本书第一章提到的，当你在构建聊天机器人时，有决策树总是好的。在这一章中，我们几乎不用任何规则，但是 ML 还没有达到 100%可靠的程度。因此，这个决定完全基于您的用例，以及您是否想在 ML 模型中应用一些业务逻辑。有时候，你的 ML 模型可能工作得很好，以至于你根本不需要任何启发。但是根据我的经验，当你继续销售你的聊天机器人或者将它们商业化的时候，你必须小心一点。没有功能总比有一个没有意义的功能好。

我们将使用一个名为 Rasa NLU 的开源库来学习如何从头开始构建聊天机器人，而不使用任何云服务，如 Dialogflow，Watson，wit.ai 等。记住，拉莎·NLU 是一个非常复杂的图书馆，里面有很多功能。我们将只涉及对我们构建聊天机器人很重要的概念和特性。

## 什么是拉莎·NLU？

Rasa NLU 是一个开源的自然语言处理库，用于聊天机器人的意图分类和实体提取。它帮助你为你的聊天机器人构建和编写定制的 NLP。

我们将在本章中讨论 Rasa 的两个部分。

*   拉莎·NLU:在拉莎·NLU 的帮助下，我们将学习为聊天机器人准备训练数据，编写配置文件，选择管道和训练模型。最后，我们将使用我们的模型预测文本的意图。我们还将学习如何使用 Rasa NLU 解析实体。

*   **Rasa Core:** 在第二部分中，我们将学习训练 **Rasa Core** 对话管理模型来准备对用户的响应。当你的聊天机器人有各种各样的意图以及他们的后续问题或回答时，这一部分就变得非常重要。与其在我们的决策树中编写大量条件，并在大型企业级应用程序的情况下花费数小时进行调试，不如教会模型创建响应。看看我们训练有素的模型在这方面表现如何会很有趣。我们不能只是把什么都以文字的形式吐槽给用户；应该说得通。

### 我为什么要用拉莎·NLU？

拉莎·NLU 不仅仅是一个有很多方法来做一些事情的图书馆。它有能力构建你能想象到的几乎任何类型的聊天机器人。Rasa 为您带来了训练机器理解文本含义的神奇能力，而不是您编写规则来理解它。

让我们从以下几点来看为什么我们应该使用 Rasa NLU:

*   Rasa NLU 是一个积极维护的项目，有一个很好的社区来支持它。

*   如果我们不想与第三方分享我们用户的敏感数据，我们必须使用像拉莎·NLU 这样的开源工具从头开始构建聊天机器人。这样，所有数据都保留在我们自己的服务器上进行处理。

*   依靠第三方服务来训练您的数据并发现用户话语的意图将需要您调用可能并不总是可靠的 API。如果他们的服务器关闭了，你的 chatbot 应用程序会怎么样？

*   使用拉沙·NLU 建造聊天机器人将会让你完全控制你的聊天机器人。您可以使用您想要的数据，按照您想要的方式对其进行训练、调整和优化。使用 Rasa NLU，我们可以试验哪种最大似然算法最适合我们的数据集，而不是依赖于固定的算法。

### 直接潜入拉萨 Into

在本节中，我们将直接进入动手部分，尝试安装 Rasa 堆栈，并通过训练数据开始构建我们的 ML 模型。我们将使用一些更酷的开源库来让我们的生活更轻松。

#### 安装 Rasa

要安装 Rasa，运行下面的 pip 命令，我们在前面的章节中尝试安装 spaCy。请注意，我们将使用 Rasa 版本 0.13.2。

```
pip install rasa-nlu==0.13.2

```

Rasa NLU 有多个用于分类意图和识别实体的组件。Rasa 的不同组件有自己的依赖集。

当我们训练模型时，拉莎·NLU 会检查是否安装了所有必需的依赖项。如果您想要安装完全使用 Rasa 库所需的全部要求，可以执行以下步骤:

```
git clone https://github.com/RasaHQ/rasa_nlu.git #Clone the repo
cd rasa_nlu #Get into the rasa directory
pip install -r alt_requirements/requirements_full.txt #Install full requirements

```

第一步可能需要一些时间。像地球一样耐心，直到它完成。

#### 决定 Rasa 的管道

Pipeline 不过是一套用来训练你的模型的算法。Rasa NLU 有两条被广泛使用的管道，分别叫做`spacy_sklearn`和`tensorflow_embedding`。让我们了解一下这两者。

*   spacy_sklearn pipeline 利用来自 GloVe 算法或脸书人工智能团队开发的 fastText 算法的预训练单词向量。

*   spacy_sklearn 在这样的情况下非常有效，假设你有这样一句话，“波士顿的天气如何？”当我们在同一个话语示例上训练我们的模型，然后要求它预测“伦敦的天气如何？”我们的模型现在足够智能，可以知道单词“Boston”和“London”是相似的，它们属于相同的意图。

*   这种管道对于小数据集非常有用。

```
spacy_sklearn

```

*   *tensor flow _ embedding*pipeline 不使用任何像 spacy_sklearn 这样预先训练好的词向量，而是根据我们自己提供的数据集进行自我调整。

*   关于 *tensorflow_embedding* 管道的好处是，我们的词向量将与我们的域一致。

*   为了用一个例子来解释 *tensorflow_embedding* 是如何工作的，在英语中，单词“play”可能与“一项运动”或“一项享受或娱乐的活动”密切相关，它可能看起来与单词“一个行为”非常不同。在一个戏剧领域中，“戏剧”和“一个行为”是密切相关的，其中“戏剧”意味着“剧作家写的一种文学形式”，非常有必要告诉我们的模型学习特定于我们的领域，而不是由于一些预先训练的模型而混淆。

```
tensorflow_embedding

```

## 从头开始训练和构建聊天机器人

如果你读过这本书的第 [3](3.html) 章，你一定很熟悉我们用 Dialogflow 搭建的“点餐聊天机器人”。你必须意识到聊天机器人的意图、实体和对最终用户的回应。

同样，在本章中，我们将采用聊天机器人的一个用例，并从头开始构建它。你不一定要用同样的例子。请随意查找您自己的用例，遵循本章中的步骤，并在本章结束时构建您自己的聊天机器人。

我们将建立一个星座机器人，它可以理解用户的查询，并告诉他们当天的星座。那么，我们开始吧。

### 建造一个占星机器人

在这个使用开源库 Rasa NLU 完全自主构建聊天机器人的例子中，我们将构建一个占星机器人。让我们决定这个聊天机器人的范围，看看它做什么和能做什么。

*   星座机器人应该能够理解问候，并回复问候。

*   机器人应该能够理解用户是否在询问星座。

*   如果用户不提供，机器人应该可以询问用户的星座。

*   如果用户不知道他/她的星座，机器人应该询问用户的出生日期(DOB)并为他们找到它。

*   机器人应该订阅/取消订阅用户获得每日星座。

*   机器人应该从现有的响应中学习，以制定新的响应。

*   机器人应该能够处理用户的拼写错误。

我们的机器人应该做的事情非常简单。

可能的意图

*   问候意图:用户以问候开始

*   获取星座意向:用户询问星座

*   用户的星座意图:用户说出星座

*   用户的 DOB 意图:用户告知他/她的 DOB

*   订阅意图:用户请求订阅

根据你设计你的机器人和编写代码的方式，你可能需要也可能不需要以上所有的意图，或者你可能需要定义一些额外的意图来涵盖我们希望我们的机器人做的所有用例。随着本章的深入，我们将尝试构建一个机器人来完成给出星座的基本任务；作为练习的一部分，我们可以添加更多的用例。

这就是我们到目前为止所做的，根据机器人和用户之间的简单对话来识别可能的意图。

### 占星机器人和用户之间的对话脚本

让我们在聊天机器人和用户之间创建一个可能的对话脚本。正如第一章中提到的，编写对话脚本就像在构建软件之前准备软件需求文档一样。它以后可能会改变，但会让您对最终的 chatbot 应用程序有一个总体的了解。

下面是我们在用户和机器人之间的对话:

*   **用户:**你好

*   **星座机器人:**你好！希望你一切都好。

*   **用户:**我想知道我的星座。

*   当然，我可以知道你的星座吗？

*   **使用者:**反复无常

*   星座机器人:对不起，你是说摩羯座吗？

*   **用户:**是。

*   星座机器人:好了，这是你今天的星座。今天你可能会感到乐观和积极。与那些感到不满足的人分享这种能量。你的态度会对你的朋友、伴侣、配偶和孩子产生深远的影响。邻居和大家庭可以在你没有意识到的情况下吸取你的精神。如果有人受伤或生气，要鼓励他。一切最终都会解决的。

*   星座机器人 **:** 你想订阅每日更新吗？如果是，就说订阅。

*   **用户:**是的，请订阅。

*   **星座机器人:**太好了，你现在订阅了。祝你愉快。

这个对话只是为了对我们的聊天机器人对话有一个公平的想法。我们可能想也可能不想根据自己的需求改变谈话的流程。

我们可以训练我们的聊天机器人模型本身来准备一个有效的响应，而不是写一堆 if…else 语句。

### 为聊天机器人准备数据

Rasa NLU 有多种方法来定义我们的自定义数据的意图及其实体。它支持 markdown 中的数据、JSON 中的单个文件或包含多个文件的目录。

我们将首先讨论最困难但高度可扩展的方法。手动创建 JSON 文件很困难，但是通过编程非常容易且可伸缩。

#### 以 JSON 格式为模型创建数据

Rasa NLU 期望的数据的 JSON 格式有一个名为 ***rasa_nlu_data*** 的顶层对象，键为 ***common_examples*** 、***entity _ synonyms***、***regex _ features***。

我们将要使用的最重要的工具是**。下面是我们的 JSON 数据的大致形式:**

 **```
{
    "rasa_nlu_data": {
        "common_examples": [],
        "regex_features" : [],
        "entity_synonyms": []
    }
}

```

JSON 数据中的 ***common_examples*** 键是用于训练我们的模型的中心位置。我们将在 ***common_examples*** 数组中添加我们所有的训练示例。

***regex_features*** 是帮助意图分类器识别实体或意图，提高意图分类准确率的工具。

让我们开始编写 JSON 文件。姑且称之为 **data.json.**

1.  创建一个名为**占星 _ 机器人**的文件夹。

2.  将当前工作目录更改为占星 _bot。

3.  开始 Jupyter 笔记型电脑#jupyter 笔记型电脑。

4.  创建一个名为 **data** 的新文件夹。

5.  点击数据文件夹，进入 Jupyter 笔记本新菜单下的“文本文件”。

6.  点击创建的文件名，将名称改为 **data.json** ，并为聊天机器人编写您的意图。

对于第 5 步和第 6 步，请随意使用您喜欢的编辑器，如 Sublime、Notepad++和 PyCharm 等。，来处理 JSON 文件。

下面是我在**数据**文件夹下的 **data.json** 的样子:

```
{
  "rasa_nlu_data": {
    "common_examples": [
      {
        "text": "Hello",
        "intent": "greeting",
        "entities": []
      },
      {
        "text": "I want to know my Horoscope",
        "intent": "get_horoscope",
        "entities": []
      },
      {
        "text": "Can you please tell me my horoscope?",
        "intent": "get_horoscope",
        "entities": []
      },
      {
        "text": "Please subscribe me",
        "intent": "subscription"
      }
    ],
    "regex_features": [],
    "entity_synonyms": []
  }
}

```

正如你所看到的，用手准备这个看起来很笨拙。你一定还记得我们在 Dialogflow 中使用的简单易用的方法。因此，让我们来看看一个很酷很有趣的工具，它可以以 Rasa 期望的格式创建训练数据。它是由 Polgár András 创建的，对于检查和修改我们之前准备的现有数据也非常有用。如果您正在处理一个必须手动创建数据的小项目，此工具可以节省大量时间。在您构建的任何完全由数据驱动的应用程序中可视化数据总是一个好主意。

因此，只需保存我们之前创建的 **data.json** 文件，直到我们使用更好的方法扩展数据收集。

#### 可视化和修改 Rasa 的 JSON 数据格式

在本节中，我们将利用一个名为 Rasa NLU 训练器的工具来可视化我们的数据。(即，我们到目前为止已经创建的数据)。这个工具也帮助我们注释数据。如果你还记得 Dialogflow 接口是在第 3 章[中解释的，那么定义实体、它们的名字和类型是非常容易的。我们将使用开源工具做同样的事情。](3.html)

Rasa NLU 教练是一个非常好和方便的工具，编辑我们的训练数据的权利，从我们的浏览器本身。处理 JSON 数据很棘手，也可能导致错误。有了这个方便的工具，我们可以很容易地添加更多的例子到我们的训练数据或编辑现有的。它节省了手动注释数据的大量时间。rasa-nlu-trainer 是一个基于 javascript 的工具，所以我们需要安装 node.js 来在我们的系统上运行这个工具。做那件事不需要超过 5 分钟。让我们按照以下步骤进行设置:

1.  前往 [`https://www.npmjs.com/get-npm`](https://www.npmjs.com/get-npm) 下载 node.js

2.  按照网站上的指导在您的系统上安装软件包。安装完成后，进入系统上一个新的终端/命令行界面，键入“npm ”,看看它是否能工作。

我已经安装了 LTS 版本 8.11.4。安装后，运行以下命令来安装 rasa-nlu-trainer:

```
sudo npm i -g rasa-nlu-trainer

```

成功安装该命令后，您将看到类似于以下内容的日志:

```
[fsevents] Success: "/usr/local/lib/node_modules/rasa-nlu-trainer/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node" already installed
Pass --update-binary to reinstall or --build-from-source to recompile
npm WARN slick-carousel@1.8.1 requires a peer of jquery@>=1.8.0 but none is installed. You must install peer dependencies yourself.

+ rasa-nlu-trainer@0.2.7
added 492 packages in 10.14s

```

即使您的消息看起来不像这样，只要它没有抛出任何错误，也不用担心。我们很快就会知道我们的 rasa-nlu-trainer 是否安装成功并且运行良好。

让我们转到之前在终端中创建的数据文件夹，并运行以下命令:

```
rasa-nlu-trainer

```

键入此命令将启动端口 55703 上的本地服务器，并在默认浏览器中打开它。它看起来有点像图 [4-1](#Fig1) 。

![../images/461879_1_En_4_Chapter/461879_1_En_4_Fig1_HTML.jpg](../images/461879_1_En_4_Chapter/461879_1_En_4_Fig1_HTML.jpg)

图 4-1

本地主机中的 rasa-nlu-trainer

如您所见，data.json 中的所有现有数据都是由这个神奇的工具挑选出来供我们删除或编辑的，我们还可以从这里添加新的示例，它将继续扩展 data.json 文件。

我建议你在你的意图中增加更多的数据，以便更好地训练这个模型。你可以在发行商提供的源代码 zip 或 repo 中获得这个 data.json，如果你正在尝试构建本章解释的相同的聊天机器人。

正如我们在第 [3](3.html) 章中使用 Dialogflow 选择话语中的实体来定义它们一样，我们可以使用这个工具做同样的事情，并为我们的实体命名，以便稍后进行解析。因此，单击示例中的切换按钮，选择文本，并通过给实体命名来添加实体。

在我定义的每个意图中，我都添加了五到六个话语示例。我们添加的示例越多，就越有利于模型的训练并提供更好的准确性。

如果您现在查看 data.json 文件，它会自动添加更多的示例。因此，继续验证您的 data.json 文件，看看您是否有从 **rasa-nlu-trainer** UI 添加的所有示例。

您还会注意到，在 data.json 文件中，您可能已经使用 rasa-nlu-trainer UI 定义的实体在 ***common_examples*** 列表中被捕获为具有 **start** 和 **end** 键，这告诉模型特定实体值在示例中的开始点和结束点。

同一个 dictionary 对象还描述了实体的值和我们定义的实体的名称。对于我们的示例，它看起来如下:

```
{
        "text": "19-01",
        "intent": "dob_intent",
        "entities": [
          {
            "start": 0,
            "end": 2,
            "value": "19",
            "entity": "DD"
          },
          {
            "start": 3,
            "end": 5,
            "value": "01",
            "entity": "MM"
          }
        ]
      }

```

### 训练聊天机器人模型

在本节中，我们将根据准备好的数据训练一个模型。由于我们使用 Jupyter Notebook 创建和管理文件，我们将创建一个新的。ipynb 并开始编写我们的 Python 代码，通过选择我们在本章前面讨论的管道之一来训练我们的模型。

#### 创建配置文件

让我们使用之前使用 Jupyter 创建 json 文件的相同方法再次创建一个 JSON 文件，并将其命名为 **config.json** 。让我们把它放在我们的数据文件夹之外(例如，在我们的项目目录——占星 _bot 中)。

向其中添加以下配置:

```
{
  "pipeline":"tensorflow_embedding",
  "path":"./models/nlu",
  "data":"./data/data.json"
}

```

如您所见，在我们的 config.json 文件中有一些重要的配置参数。让我们试着去理解它们。

*   管道:管道将指定使用什么样的特征化器或特征提取器来处理文本消息并提取必要的信息。在我们的例子中，我们使用了 *tensorflow_embedding* 。

*   **path** : path 本质上是我们在训练后保存模型的目录。我们将把我们的模型保存在/models/nlu 文件夹中。

*   **数据**:数据是我们需要指定的路径；它基本上是我们的训练数据所在的地方。

当我们完成了 config.json 文件之后，让我们转到一些 Python 代码来训练我们的 ML 模型。

### YAML 构型

也可以用。yml 文件作为配置文件，如下所示。您可以在 github repo 中获得示例 config.yml 文件。

*   **例 1:**

*   **例 2:**

```
language: "en"
pipeline: "tensorflow_embedding"

```

```
language: "en"
    pipeline:
    - name: "nlp_spacy"
    - name: "tokenizer_spacy"
    - name: "intent_entity_featurizer_regex"
    - name: "intent_featurizer_spacy"
    - name: "ner_crf"
    - name: "ner_synonyms"
    - name: "intent_classifier_sklearn"

```

所有传入的消息都按照定义的组件顺序进行处理。已定义的组件按顺序一个接一个地运行，因此被称为处理管道。不同的组件用于不同的目的，例如实体提取、意图分类、预处理等。

这种格式的好处是，我们可以通过 Rasa 以一种清晰的方式指定预定义的管道。

#### 编写 Python 代码来训练模型和预测

让我们打开一个新的。ipynb 文件并开始编写我们的代码。让我们将 ipynb 命名为 rasa-nlu.ipynb。确保您已经成功安装了您正在使用的 Python 版本的`rasa-nlu==0.13.2`。

下面是我们的代码在 Python 中使用我们的 data.json 和 config.json，并使用 *tensorflow_embedding* 管道训练一个模型的样子。

```
from rasa_nlu.training_data import load_data
from rasa_nlu.model import Trainer
from rasa_nlu import config
from rasa_nlu.model import Interpreter

def train_horoscopebot(data_json, config_file, model_dir):
    training_data = load_data(data_json)
    trainer = Trainer(config.load(config_file))
    trainer.train(training_data)
    model_directory = trainer.persist(model_dir, fixed_model_name = 'horoscopebot')

def predict_intent(text):
    interpreter = Interpreter.load('./models/nlu/default/horoscopebot')
    print(interpreter.parse(text))

```

在代码的第一部分，我们从 rasa_nlu 包中导入所有必需的库。然后，我们定义了两个方法，称为*train _ 占星机器人*和 *predict_intent* ，其中第一个方法在给定数据、配置文件和模型目录(存储模型的位置)的情况下训练模型，predict_intent 方法使用 rasa_nlu 的**解释器**模型来加载预训练的模型文件，并让用户能够预测任何新的文本示例。

#### 训练模型

我们运行下面的代码片段，用各自的参数调用我们的 train _ astrong bot 方法

```
train_horoscopebot('./data/data.json', 'config.json', './models/nlu')

```

在我们的 rasa-nlu.ipynb 中运行这段代码后，我们将得到如下输出:

```
Epochs: 100%|██████████| 300/300 [00:01<00:00, 175.69it/s, loss=0.075, acc=1.000]

```

用于训练聊天机器人模型的代码将创建模型文件夹，您可以使用 Jupyter 或您的文件资源管理器或 finder 应用程序看到该文件夹。它将在我们提供的模型目录目的地创建一组索引、元和 pickle 文件。

### 从模型中预测

让我们通过传递文本来调用 predict_intent 方法，以查看我们的训练模型的执行情况。

```
predict_intent("I am looking for my horoscope for today. I am wondering if you can tell me that.")

```

该方法本身打印输出。对于上面的文本，我的输出如下所示:

```
INFO:tensorflow:Restoring parameters from ./models/nlu/default/horoscopebot/intent_classifier_tensorflow_embedding.ckpt

{
  "intent": {
    "name": "get_horoscope",
    "confidence": 0.9636583924293518
  },
  "entities": [],
  "intent_ranking": [
    {
      "name": "get_horoscope",
      "confidence": 0.9636583924293518
    },
    {
      "name": "dob_intent",
      "confidence": 0.03462183475494385
    },
    {
      "name": "greeting",
      "confidence": 0
    },
    {
      "name": "subscription",
      "confidence": 0
    }
  ],
  "text": "I am looking for my horoscope for today. I am wondering if you can tell me that."
}

```

哇！是不是很神奇？我们的模型以 96%的置信度预测了这段文字。您可以在提供的 ipynb 文件中看到，我们的模型在预测其他意图方面也做得很好。这就是 tensorflow 和 ML 整体的力量。rasa_nlu 库就不用说了，让它这么容易相信。所以，现在是你回顾过去的时候了，如果你还记得本书的第 3 章，那么你一定还记得每当我们添加一个新的例子时，用于重新训练模型的对话流。在幕后，它实际上和我们刚才做的一样。我们不能改变模型或调整任何参数，但我们现在可以完全控制这些。

既然我们已经使用 tensorflow 成功地构建和训练了一个模型，并对其进行了测试，我们将继续讨论对话管理的下一个主题。我会要求您测试您的机器人可能面临的所有场景，以便您知道您的模型在哪些方面表现不佳，因此，如果需要，您可以添加更多数据或调整参数。

此外，请记住，只要训练数据发生变化，您就只需要重新训练模型。如果训练数据没有变化，我们可以加载现有的训练模型来继续预测新的示例。

## 使用 Rasa 核心的对话管理

在这一节中，我们将通过培训另一个 Rasa 核心对话管理模型来动手实践。请记住，此时我们已经有了一个模型来预测文本的意图，我们可以编写一些 Python 代码来制定响应，并且我们可以回复客户。但是如果我们想给我们的机器人添加更多的意图呢？在具有大量特性的大型应用程序中，这种方法是否具有可伸缩性？答案是否定的。Rasa Core 的对话管理解决了这个问题。

如果你曾经尝试在任何平台上使用任何机器人，你一定会看到它在某些条件下失败。是的，我们都经历过这种情况，它仍然存在，因为今天的机器人无法悲惨地管理对话的上下文或遵循对话的规则。借助 Rasa Core 基于 ML 的对话框架，我们可以轻松解决这个问题。Rasa Core 已经为企业级应用程序提供了很好的证明，并被成千上万的开发人员使用，因为它是生产就绪的，易于使用和扩展，最重要的是，它是开源的。

### 更多了解 Rasa 核心和对话系统

在我们真正进入我们的对话管理模型的 Rasa 核心的编码部分之前，理解为什么和从哪里来是非常重要的。

我们将努力理解我们迄今为止是如何构建聊天机器人的，以及这将如何被永远改变。

让我们举个例子:

如果我们要构建一个简单的聊天机器人，帮助用户预订航班/公共汽车/电影/火车票，最简单的方法是创建一个状态机或决策树，写一堆 if…else，就可以完成了。这可以工作，但无法扩展。如果顾客最初对某样东西有很好的体验，他们会想更多地使用它。通过一些试探法，我们可以证明聊天机器人是聪明的，但不会持续很长时间。当代码的控制流从 try 块到 except 块，我们就开始挠头了。

图 [4-2](#Fig2) 是构建这个聊天机器人的状态机的简单表示。

![../images/461879_1_En_4_Chapter/461879_1_En_4_Fig2_HTML.jpg](../images/461879_1_En_4_Chapter/461879_1_En_4_Fig2_HTML.jpg)

图 4-2

订票聊天机器人的状态图表示

如果我们看一下我们的状态图，它可能适用于一个普通的对话，在这个对话中，用户正在寻找电影票、公共汽车票或火车票，或者在索要电影票之后想要预订一张公共汽车票。如果用户同时要公交票和电影票怎么办？你可能会说，我们可以在已经嵌套的代码中再添加几个 if…else 语句来处理这个问题。如果你是一个优秀的开发人员，从状态机写一个 in-out 或者扩展你的决策树不会花你太多时间。但是想象一下，当这些情况开始呈指数级增长时，你必须不断增加病例来处理，它们也开始相互干扰。

我们的大脑以一种学习和再学习的方式工作。如果一个孩子不知道火会对他们做什么，他们会去碰它，但是当它伤害了他们，他们不会再去做了。他们强调了一个事实，那就是它是有害的。奖励也是如此——当你做了某件事并得到某样东西时，你会联想到这样一个事实:做某件事会带来奖励或更好的奖励，然后你打算再做一次。这在 ML 中被称为强化学习，机器通过执行动作和理解结果来学习如何在特定情况下表现。强化学习有时不是最好的方法，例如在数据不足以学习的情况下，数据质量不好以学习奖励场景等。

图 [4-3](#Fig3) 是帮助您理解 Rasa 核心如何很好地适应 Rasa 堆栈及其与 Rasa NLU 的作用的图表，这是我们到目前为止一直在学习的。

![../images/461879_1_En_4_Chapter/461879_1_En_4_Fig3_HTML.jpg](../images/461879_1_En_4_Chapter/461879_1_En_4_Fig3_HTML.jpg)

图 4-3

图中显示了 Rasa NLU 和 Rasa 核心的工作情况

使用 Rasa Core，我们可以指定我们的机器人应该说或做的所有事情。这些被称为*动作*。一个动作可能是向用户打招呼或查询数据库，也可能是使用某种 web 服务或 API 检索某些信息。

Rasa Core 提供了训练我们的概率模型的工具，以根据用户的历史对话来预测必须采取什么行动。想象一下，在没有 ML 模型的情况下，编写数百个用例来计算应该发送或执行什么响应或动作。简单来说，Rasa Core 为你解决了这个问题。

让我们看看我们在第 [3](3.html) 章构建在线机器人时构建的用户与机器人的并行对话。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

**用户**

 | 

网上吃饭

 |
| --- | --- |
| 你好 OnlineEats | 你好！我能帮你什么吗？ |
| 我想点菜 | 当然，你今天想要订购什么？ |
| 一个鸡肉汉堡 | 完成了。你的最终金额是 3.99 美元 |
| 谢谢你 | 非常感谢 |

这种对话非常简单，即使我们确实使用了一个训练有素的模型来识别其中的意图和实体，也可以在没有任何 ML 模型的情况下完成。

现在，你会想到一个有趣的问题，“如果我想让我的机器人能够改变顺序，该怎么办？如果我希望我的机器人能够移除或添加更多数量的食物，该怎么办？”因此，正如所讨论的，在代码中添加更多的用例、更多的复杂性、更多的意图及其表达方式、更多的 if…else 来处理角落情况，但是当你为一个企业构建聊天机器人时，你必须扩展它以通过它产生更多的收入。所有的软件系统都是这样做的，那些没有失败的都活了下来。底线是，我们不能一直改变和部署代码。

因此，我们可以在 Rasa Stack 的帮助下，采取 ML 路线来解决这个问题，而不是在所有情况发生时处理它们并重复这样做，Rasa Stack 会根据用户的上下文和对话状态告诉我们机器人下一步应该做什么。由于模型根据之前对话数据的上下文进行自我学习，因此机器人更容易保持对话更加自然和用户友好，而不是随机选择四到五个固定的句子。

Rasa 建议数据很少或没有数据的用户使用交互式学习。在本章的后面，我们将了解更多关于**互动学习**的内容。

在我们真正开始使用 Rasa Stack 编写我们的 bot 的核心部分之前，首先我们需要理解几个概念。

### 理解 Rasa 概念

在真正尝试在代码中完全使用 Rasa 之前，理解一些与 Rasa 相关的特定概念非常重要。在这一部分，我们将学习一些重要且非常有用的拉莎·NLU 概念。请确保您完全理解这些概念，因为我们将使用 Rasa 的域文件格式来构建我们的第一个内部聊天机器人。如果我们不理解这些概念的含义，那么就很难迈出下一步。

#### 行动

顾名思义，这是一个可以采取的具体行动。根据 Rasa 文档，它说，“`Next action to be taken in response to a dialog state`”

例如，如果用户询问今天的星座运势，我们的机器人可以执行“GetTodaysHoroscope”动作。让我们看看一个“GetTodaysHoroscope”动作在代码中是什么样子的。

```
from rasa_core.actions import Action
from rasa_core.events import SlotSet

class GetTodaysHoroscope(Action):
   def name(self):
      return "get_todays_horoscope"

   def run(self, dispatcher, tracker, domain):
      # type: (Dispatcher, DialogueStateTracker, Domain) -> List[Event]

      user_horoscope_sign = tracker.get_slot('horoscope_sign')
      """Write your logic to get today’s horoscope details
         for the given Horoscope sign based on some API calls
         or retrieval from the database"""

return [SlotSet("horoscope_sign", user_horoscope_sign)]

```

**name** 方法返回动作的名称，我们将在域文件中将其称为自定义方法名称。

**run** 方法完成完成动作的主要工作——也就是说，核心业务逻辑驻留在这里。如你所见，它需要三个参数:*分派*、*追踪器*和*域。*

让我们逐一了解这些参数:

*   **dispatcher:**dispatcher 用于向我们的用户发回消息。我们可以使用`dipatcher.utter_message()`来达到同样的目的。

*   **跟踪器:**当前用户的状态跟踪器。我们可以使用`tracker.get_slot(slot_name),`来访问槽值，并且可以使用`tracker.latest_message.text`来获取最新的用户消息。

*   **域:**bot 的域。我们将在本章后面更详细地讨论这个领域。

### 注意

run 方法返回事件实例列表。

#### 时间

插槽是那些让机器人负责像人类一样工作的东西。插槽就像一个存储空间，可以存储用户给出的信息，也可以使用从数据库或 API 预取的信息。

不同的使用情形有不同的插槽类型:

例如，在我们想要构建星座机器人的用例中，我们可能想要使用插槽类型作为用户提供的**星座符号**的`text`。

根据您想要保留的插槽类型，Rasa 提供了一些预定义的插槽类型。

除文本外，Rasa 还有以下插槽类型:

*   **布尔型**用于真/假

*   **分类**用于您必须选择某个值的情况

*   **Float** 用于连续值

*   **列表**用于值列表

*   **特色化**用于不影响通话的内部值存储

#### 模板

当你在寻找发送电子邮件、准备文档、建立作品集网站或遵循流程的模板时，模板是一个你在生活中至少听过一次的词。

Rasa 中的模板用于话语。话语模板包含一组预设文本，当某个动作被触发时，这些文本将被发送给用户。通过使用与话语相同的动作名称或者使用自定义代码的动作，我们可以将格式化的消息以模板的形式发送给用户。

域文件中模板的简单表示可能如下所示:

```
templates:
  utter_greet:
    - "hello {name}!"   # name can be filled by a slot of same name or by custom code
  utter_goodbye:
    - "goodbye"
    - "take care bye"   # multiple templates allow the bot to randomly pick from them
  utter_default:
    - "Sorry, I didn’t get that."

```

现在，我们已经学习了动作、插槽和模板这三个概念，并且我们已经知道了意图和实体是什么，作为我们从第 [3](3.html) 章学习的一部分，我们现在准备深入 Rasa 并开始为我们的第一个聊天机器人编写代码。

### 正在为聊天机器人创建域文件

使用 Rasa stack 构建聊天机器人的首要任务是创建一个域文件。

根据 Rasa 的文档，“域定义了你的机器人运行的宇宙。它指定了你的机器人应该知道的意图、实体、插槽和动作。可选地，它还可以包括你的机器人可以说的东西的模板。”

现在，通过了解 Rasa 的核心概念，你知道为什么我们必须事先为这种情况做好准备。

让我们用 YAML 定义创建一个 DefaultDomain 文件。拉莎使用。yml 文件来定义域格式。

最初 YAML 的意思应该是`Yet Another Markup Language,`描述它作为一种标记语言的使用，但后来它被理解为 YAML 不是标记语言，一种递归的缩写，以区分它作为面向数据而不是文档标记语言的目的。

现在，让我们回到 rasa-nlu Jupyter 笔记本目录，开始创建文件。请注意，我们可以使用命令行在单独的文件中编写所有代码，并使用编辑器对其进行编辑。我发现 Jupyter 笔记本更具互动性，浏览文件也更容易。无论你觉得哪种都可以，但是了解 Jupyter Notebook 提供的大部分功能还是有好处的。

转到主占星 _bot 目录下，创建一个文件，姑且称之为`horoscope_domain.yml`。

以下是我们 bot 的`horoscope_domain.yml`内容:

```
slots:
    horoscope_sign:
        type: text
    DD:
        type: text
    MM:
        type: text

    subscribe:
        type: bool

intents:
    - greeting
    - get_horoscope

    - subscription
    - dob_intent

entities:
     - horoscope_sign
     - DD
     - MM
     - subscribe
     - dob_intent

templates:
    utter_greet:
        - 'Hello! How are you doing today?'
    utter_ask_horoscope_sign:
        - 'What is your horoscope sign?'
    utter_ask_dob:
        - 'What is your DOB in DD-MM format?'
    utter_subscribe:
        - 'Do you want to subscribe for daily updates?'

actions:
  - utter_greet
  - utter_ask_horoscope_sign
  - utter_ask_dob
  - utter_subscribe
  - get_todays_horoscope
  - subscribe_user

```

正如您所看到的，域文件由五个重要部分组成:`intents, entities, slots, templates`和`actions`，我们在前面已经讨论过了。

注意，对于每个模板，都定义了一个 utterAction，比如`utter_greet, utter_ask_horoscope_sign`和`utter_ask_dob`，我们必须在模板部分定义一个同名的模板。

正如您在我们的示例中看到的，主要定义了五个动作，其中前三个动作只是为了向用户说出模板文本，但最后两个动作要求我们要么从数据库中检索数据，要么调用 API 来获取当天的星座并将其返回给用户。

对于`subscribe_user`动作，我们需要做一个操作，将当前用户添加到数据库的订阅列表中。这些用户定义的操作称为自定义操作。为了拥有这样的自定义动作，我们需要编写当这些动作被触发时，机器人应该做什么。

在下一节中，我们将学习如何编写自定义操作。

## 编写聊天机器人的自定义动作

正如我们所知，每当一个`UtterAction`被触发，我们的机器人会用模板中为该动作定义的完整文本进行响应。但是当一些自定义动作被触发时会发生什么呢？在这一节中，我们将编写 Python 代码来创建自定义操作，我们可以用它来进行 API 调用或几乎任何你可以用 Python 做的事情。

让我们在我们的项目目录中创建一个名为`actions.py`的新文件(即，在我们的例子中，在`horoscope_bot`文件夹中)。

```
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import requests
from rasa_core_sdk import Action
from rasa_core_sdk.events import SlotSet

class GetTodaysHoroscope(Action):

    def name(self):
        return "get_todays_horoscope"

    def run(self, dispatcher, tracker, domain):
        # type: (Dispatcher, DialogueStateTracker, Domain) -> List[Event]

        user_horoscope_sign = tracker.get_slot('horoscope_sign')
        base_url = http://horoscope-api.herokuapp.com/horoscope/{day}/{sign}
        url = base_url.format(**{'day': "today", 'sign': user_horoscope_sign})
        #http://horoscope-api.herokuapp.com/horoscope/today/capricorn
        res = requests.get(url)
        todays_horoscope = res.json()['horoscope']
        response = "Your today's horoscope:\n{}".format(todays_horoscope)

        dispatcher.utter_message(response)
        return [SlotSet("horoscope_sign", user_horoscope_sign)]

```

正如我们所看到的，在我们的操作中有两个方法叫做 GetTodaysHoroscope。第一个方法 **name** 只是返回动作的名称。另一个方法是**运行**，正如前面讨论的，这个方法通过执行我们编写的业务逻辑来实际完成任务。

在我们的方法中，我们使用了一个开源 API，代码托管在 github [ [`https://github.com/tapasweni-pathak/Horoscope-API`](https://github.com/tapasweni-pathak/Horoscope-API) ]上

API url 如下所示:

[T2`http://horoscope-api.herokuapp.com/horoscope/today/capricorn`](http://horoscope-api.herokuapp.com/horoscope/today/capricorn)

它以 JSON 格式返回数据:

```
{
  "date": "2018-08-29",
  "horoscope": "You will be overpowered with nostalgia and may long to get in touch with old pals. And as Ganesha says, chances are that you may take a liking to your ex-lover, while simultaneously strengthening your social standing. All in all, the day will be a productive one.",
  "sunsign": "capricorn"
}

```

正如你在 **run** 方法中看到的，我们将来自 API 的响应转换为 Python JSON 对象，然后从 JSON 中访问“星座”键以获得实际的星座。在从 JSON 中获得实际的星座之后，我们使用`dispatcher`对象及其方法 utter_message 制定一个响应并将其发送回用户。

最后，我们使用`SlotSet`方法设置插槽。SlotSet 就像保存您从用户的响应中发现的变量，这样您就可以在对话过程中的任何时候在代码中使用它们。

### 注意

使用上面的 API，我们可以通过提供星座来获得今天的星座。你可以自由使用你自己的 API 或者数据库。您只需要将 API 调用替换为您想要使用的其他资源。

就像我们在`actions.py`文件中添加了`GetTodaysHoroscope`动作一样，我们也将添加`SubscribeUser`动作。我们不打算使用任何数据库来存储用户的订阅偏好，但是当您为真实用户构建聊天机器人时，您可能必须拥有可以在数据库中与他们的订阅相关联的 user _ ids。

以下是 SubscribeUser 操作的外观:

```
class SubscribeUser(Action):
    def name(self):
        return "subscribe_user"

    def run(self, dispatcher, tracker, domain):
        # type: (Dispatcher, DialogueStateTracker, Domain) -> List[Event]

        subscribe = tracker.get_slot('subscribe')

        if subscribe == “True”:
            response = "You're successfully subscribed"
        if subscribe == “False”:
            response = "You're successfully unsubscribed"

        dispatcher.utter_message(response)
        return [SlotSet("subscribe", subscribe)]

```

像这样，我们可以根据需要编写任意多的自定义操作。

接下来就是数据了。Rasa 的对话管理模型是在用户和聊天机器人的实际对话中训练出来的。这里重要的一点是，这些对话必须转换成故事的形式。

故事只不过是用户和聊天机器人之间的实际对话，其中用户的输入被转换为意图和实体，而聊天机器人返回的响应被视为聊天机器人在需要时应该触发的动作。

下表给出了用户和聊天机器人之间的真实对话看起来像故事的一个例子。

情景一

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

**用户**

 | 

**星座运势**

 |
| --- | --- |
| 你好。 | 发出问候 |
| 我想知道我今天的星座运势 | 说出星座 |
| 我的星座是摩羯 | 动作(s)。gettodayhorocscope-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯 |
| 你能帮我订阅更新吗？ | 行动。订户用户 |

情景二

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

**用户**

 | 

**星座运势**

 |
| --- | --- |
| 你好。 | 发出问候 |
| 我想知道我今天的星座运势 | 说出星座 |
| 我不知道我的星座 | 直言不讳 |
| 12-12 | 动作(s)。gettodayhorocscope-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯-格达多约罗斯 |

我们还没有涵盖代码中用户不知道他的星座，但知道他的出生日期的场景。这里，我们的代码需要做一些修改，以便在找不到星座值时获得日期和月份实体。

我们可以使用 DD-MM 值来检查星座，然后显式地调用 GetTodaysHoroscope 方法，或者以这种方式训练模型。

## 训练机器人的数据准备

在进行任何类型的 ML 之前，拥有高质量的数据总是很重要的。为了训练我们的聊天机器人，我们也需要数据；用户和聊天机器人之间的对话是我们需要用来训练模型的数据。有时很难在网上找到一个符合我们需要的数据集。

我们应该花我们需要的时间来收集数据。我们可以要求我们的朋友和家人向我们提供示例对话文本，说明他们将如何与您正在构建的一种机器人进行交互。有些人为此创建了示例应用程序，并对数据进行了众包。所以，数据越好，模型越好，聊天机器人的反应越好。

当谈到准备数据时，Rasa 想尽一切办法，并提供了一个很酷的功能，称为**互动学习**。它帮助您轻松地生成故事数据，并在我们不断添加故事数据时训练对话管理模型。你可以称之为实时 ML 训练。因此，随着我们不断添加我们的故事数据，我们开始知道我们的模型是否产生正确的输出。最重要的是，当我们添加新的故事时，我们可以看到模型是在改进还是在退化。在大多数情况下，它会变得更好，因为我们会做一些强化学习，我们告诉 ML 模型去遗忘和重新学习——就像人类做的那样。

### 创建故事数据

正如我们所知，故事数据只是用户和聊天机器人之间的一种对话方式，讨论它将如何导致逻辑上的结束。一般来说，所有聊天机器人都是为了帮助用户完成一组预定义的事情；故事只是代表了他们是怎么做的。

我们将尝试按照 Rasa 期望的格式准备一些简单的对话。这些对话将是无状态的，也就是说，它们不依赖于以前的对话。我们将使用我们手工制作的无状态故事进行互动学习。

我们将花几分钟时间来手工整理几个我们知道的故事，以便我们适应故事数据是如何创建的。

让我们首先在我们的**数据**文件夹中创建一个名为`stories.md`的文件。

```
## story_001
* greeting
  - utter_greet
* get_horoscope
  - utter_ask_horoscope_sign
* get_horoscope{"horoscope_sign": "Capricorn"}
  - slot{"horoscope_sign": "Aries"}
  - get_todays_horoscope
  - utter_subscribe

## story_002
* greeting
  - utter_greet
* get_horoscope{"horoscope_sign": "Capricorn"}
  - slot{"horoscope_sign": "Cancer"}
  - get_todays_horoscope
  - utter_subscribe
* subscription
  - slot{"subscribe": "True"}
  - subscribe_user

## Horoscope query with horoscope_sign

* greeting
    - utter_greet
* get_horoscope
    - utter_ask_horoscope_sign
* get_horoscope{"horoscope_sign": "capricorn"}
    - slot{"horoscope_sign": "capricorn"}
    - get_todays_horoscope
    - slot{"horoscope_sign": "capricorn"}
    - utter_subscribe
* subscription{"subscribe": "True"}
    - slot{"subscribe": "True"}
    - subscribe_user
    - slot{"subscribe": true}

## Horoscope with sign provided
* greeting
    - utter_greet
* get_horoscope{"horoscope_sign": "leo"}
    - slot{"horoscope_sign": "leo"}
    - get_todays_horoscope
    - slot{"horoscope_sign": "leo"}
    - utter_subscribe
* subscription{"subscribe": "True"}
    - slot{"subscribe": "True"}
    - subscribe_user
    - slot{"subscribe": true}

## When user directly asks for subscription
* greeting
    - utter_greet
* subscription{"subscribe": "True"}
    - slot{"subscribe": "True"}
    - subscribe_user
    - slot{"subscribe": true}

```

如果你盯着这些故事看几分钟，它们会向你坦白它们的意思；弄清楚正在发生的事情应该不难。前两个故事之间的主要区别是，在第一个故事中，用户没有提到他的星座，机器人应该问星座，然后继续这个故事。

在第二个故事中，用户自己说出星座，然后用订阅对话框结束故事。我们增加了几个故事，涵盖了更多的用例。请随意在同一个文件中添加您自己的故事。

所以，基本上故事是降价文件，我们可以按照前面显示的降价格式写尽可能多的故事。手工完成这项任务似乎有点困难。因此，我们将尝试学习如何使用 Rasa 自己的**互动学习**工具来生成更多这样的故事。

让我们开始吧。

### 互动学习

到目前为止，我们一直在零零碎碎地谈论交互式学习，但现在是时候实际编写一些代码并付诸实践了。交互式学习是 Rasa 最酷的功能之一，它使 ML 部分变得有趣和简单。有两个部分:在第一部分中，我们通过使用各种策略给出我们的初始数据集来训练模型，在第二部分中，我们测试模型，修正它，并以交互的方式重新训练它。

#### 训练聊天机器人代理模型

让我们在主项目目录中创建一个名为`train_initialize.py`的新文件。`train_initialize.py`的内容是这样的:

```
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from rasa_core import utils
from rasa_core.agent import Agent
from rasa_core.policies.keras_policy import KerasPolicy
from rasa_core.policies.memoization import MemoizationPolicy
from rasa_core.policies.sklearn_policy import SklearnPolicy

if __name__ == '__main__':
    utils.configure_colored_logging(loglevel="DEBUG")

    training_data_file = './data/stories.md'
    model_path = './models/dialogue'

    agent = Agent("horoscope_domain.yml",
                  policies=[MemoizationPolicy(), KerasPolicy()])

    training_data = agent.load_data(training_data_file)

    agent.train(
            training_data,
            augmentation_factor=50,
            epochs=500,
            batch_size=10,

            validation_split=0.2
    )

    agent.persist(model_path)

```

这是我们写在`train_initialize.py`文件中的代码。现在，在我们进入下一个代码文件之前，让我们先试着理解其中的要点。

1.  首先，我们从 __future__ 模块中导入一些方法。Python 中的未来语句有特殊的用法，它们改变了 Python 模块的解析方式，也改变了现有方法的行为方式。

    ```
    Curious personality ? Try the below code in your python interpreter
         from __future__ import braces

    ```

2.  从 rasa_core 模块导入`utils`方法来配置日志记录。

3.  从代理模块导入代理类以创建代理对象。

4.  KerasPolicy，KerasPolicy 将作为策略参数传递给代理类。

5.  **configure _ colored _ logging:**utils . py 中定义的使用 Python 的 coloredlogs 包进行彩色日志记录的实用方法。

6.  **Agent:**Rasa 定义的一个类，提供一个接口来利用最重要的 Rasa 核心功能，比如训练、处理消息、加载对话模型、获取下一个动作、处理通道。

7.  **load_data:** 从给定路径加载训练数据。

8.  **train:** 使用提供的文件中的数据训练给定的策略/策略集合。

9.  **训练 _ 数据:**加载 _ 数据**方法返回的**对象。`DialogueStateTracker`列表。这只是我们的训练数据文件。

10.  **augment _ factor:**告诉 Rasa 在给定初始故事集的情况下应该创建多少个虚拟故事。10x 因子是用于训练数据生成器的扩充回合的启发。

11.  **历元:** 1 个历元是整个训练数据集上的完整训练周期。训练数据向前和向后传递的总数。

12.  **batch_size:** 告诉您每次使用的训练样本的数量。batch_size 为 10 的 100 个示例将需要 10 个历元来遍历整个数据集。

13.  **validation_split:** 验证模型无偏准确性的数据百分比。

14.  **persist:** 该方法用于将代理对象持久保存在给定的目录中，以便重用。

此时，您应该非常清楚每个方法的作用以及代码内部发生了什么。

在我们继续运行这个脚本之前，确保在执行这个脚本之前已经安装了 rasa_core 库。

您可以使用以下命令安装 rasa_core:

```
pip install rasa_core==0.11.1

```

如果你遵循本书中的聊天机器人示例，那么确保你只安装了上述版本，因为 Rasa 可能不是向后兼容的。他们正迅速提出更新更优化的方法。

### 最新的 rasa_core

您也可以从 github repo 安装 rasa_core 的最新版本。你只需要执行下面这组命令，这些命令会在安装之前直接从 github 获取最新的代码。

```
git clone https://github.com/RasaHQ/rasa_core.git
cd rasa_core
pip install -r requirements.txt
pip install -e .

```

让我们试着运行这个代码文件，按照给定的参数训练我们的模型。

```
$python train_initialize.py

```

您也可以使用 Jupyter 的 magic 命令从 Jupyter 笔记本本身运行该脚本，如下所示:

如果您已经为 python3 安装了 rasa，请使用 python3

在我们这样的小数据集上训练模型应该需要大约 25 到 30 秒。我在策略列表中添加了`SklearnPolicy`以及 MemorizationPolicy 和 KerasPolicy 来训练我的模型。不同的政策有各自的好处。阅读更多关于它们的内容，以了解哪一种可能更适合您的用例；对于我的数据集，SklearnPolicy 有时似乎比 KerasPolicy 表现得更好。

脚本执行完毕后，您应该会看到一些成功的消息，如下所示:

```
2018-08-30 04:24:31 INFO    rasa_core.policies.keras_policy  - Done fitting keras policy model
2018-08-30 04:24:31 INFO    rasa_core.featurizers  - Creating states and action examples from collected trackers (by MaxHistoryTrackerFeaturizer)...
Processed trackers: 100%|████████| 96/96 [00:00<00:00, 898.31it/s, # actions=75]
2018-08-30 04:24:31 INFO    rasa_core.featurizers  - Created 75 action examples.
2018-08-30 04:24:31 INFO    rasa_core.policies.sklearn_policy  - Done fitting sklearn policy model
2018-08-30 04:24:31 INFO    rasa_core.agent  - Model directory models/nlu exists and contains old model files. All files will be overwritten.
2018-08-30 04:24:31 INFO    rasa_core.agent  - Persisted model to '/Users/sumit/apress_all/Chapter IV/horoscope_bot/models/nlu'

```

您还会发现几个根据型号名称创建的文件夹。确保您在脚本中给出的 model_path 中有它们。以下是我在 model_path 文件夹中看到的文件夹/文件。

```
policy_0_MemoizationPolicy
policy_1_KerasPolicy
policy_2_SklearnPolicy
domain.json
domain.yml
Policy_metadata.json

```

如果您已经验证了您的模型已经成功地完成了执行，并且在您的本地系统中持久化了模型，那么我们就可以进入下一步的交互式培训了。

#### 通过强化进行实时训练

在这一节中，我们将编写更多的代码来训练我们的对话模型，并在它给出不正确的输出时进行重新训练。

因此，当我们的机器人做错了什么，我们会立即跳出来，通过告诉它什么是正确的，让模型知道它的预测是错误的。无需停止，模型会重新训练自己，一旦我们完成，用户和机器人之间的交互就会被捕获到一个文件中，并添加到我们现有的训练数据中。它在每一步都更像一个反馈系统，而不是在最后等待一个单一的奖励。

下一步是用下面的内容创建一个名为`endpoints.yml`的新文件。我们将在 Python 代码文件`train_online.py.`中使用这个文件。通过这个配置，我们可以将 Rasa 方法公开为 HTTP APIs。

```
action_endpoint:
  url: http://localhost:5055/webhook

#nlg:
#  url: http://localhost:5056/nlg

core_endpoint:
  url: http://localhost:5005

```

现在，让我们为我们的在线/交互式培训创建`train_online.py`。

```
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import logging

from rasa_core import utils, train
from rasa_core.training import online
from rasa_core.interpreter import NaturalLanguageInterpreter

logger = logging.getLogger(__name__)

def train_agent(interpreter):
    return train.train_dialog_model(domain_file="horoscope_domain.yml",
                                      stories_file="data/stories.md",
                                      output_path="models/dialog",
                                      nlu_model_path=interpreter,
                                      endpoints="endpoints.yml",
                                      max_history=2,
                                      kwargs={"batch_size": 50,
                                              "epochs": 200,
                                              "max_training_samples": 300
                                              })

if __name__ == '__main__':
    utils.configure_colored_logging(loglevel="DEBUG")
    nlu_model_path = "./models/nlu/default/horoscopebot"
    interpreter = NaturalLanguageInterpreter.create(nlu_model_path)
    agent = train_agent(interpreter)
    online.serve_agent(agent)

```

`max_history`是模型要跟踪的状态数。

在我们继续运行我们的最终脚本`train_online.py`之前，我们应该了解并为 rasa-nlu-sdk 做好准备。

#### rasa-nlu SDK

Rasa NLU 堆栈提出了 rasa-nlu-sdk，这是一个 Python SDK，用于为 Rasa 核心开发自定义操作。至于我们的聊天机器人示例，我们需要定义一些自定义操作，比如点击 API 来获取今天的星座，或者可能是数据库写操作来将用户添加到订阅列表。

好消息是他们有一个单独的库，我们可以使用 pip 来安装它。

让我们使用以下命令来安装它:

```
pip install rasa-core-sdk==0.11.0

```

现在，我们需要转到终端的另一个选项卡或一个新的命令行，并在我们的项目目录(我们的`actions.py`文件所在的位置)中执行以下命令:

```
python -m rasa_core_sdk.endpoint --actions actions

INFO:__main__:Starting action endpoint server...
INFO:rasa_core_sdk.executor:Registered function for 'get_todays_horoscope'.
INFO:rasa_core_sdk.executor:Registered function for 'subscribe_user'.
INFO:__main__:Action endpoint is up and running. on ('0.0.0.0', 5055)

```

该命令将启动一个动作服务器，该服务器将监听模型预测的任何自定义动作。一旦任何动作被触发，它将执行它并根据方法给出响应。

在本地主机上，操作服务器端点的默认端口是 5055。如果你想改变它，你可以在命令行中添加 pass `--port`参数。

一个快速的问题浮现在脑海:为什么？为什么我需要一个单独的服务器？为什么不能用普通 Python？是的，我们可以使用普通的 Python，但是假设您要用任何其他语言来开发所需的操作，或者您已经将一些操作公开为 API。现在，您只需要转到我们已经创建的`endpoints.yml,`，并使用它来说明应该在哪里使用您的操作服务器以及应该在哪里使用您的 core_endpoint 服务器。在生产系统中，两者可以是具有完全不同的 URL 的不同服务器。

现在，当我们运行下一个脚本时，其中提到了我们的 endpoints.yml 文件，Rasa 将读取该文件并获取我们的 action_server 的配置，它已经按照我们之前所做的配置启动并运行。

```
action_endpoint:
       url: http://localhost:5055/webhook

```

让我们在新的命令行终端中运行`train_online.py`。

```
$python3 train_online.py

```

在对话模型的成功训练之后，我们将得到这样的消息:

```
2018-08-30 07:09:37 INFO     rasa_core.policies.keras_policy  - Done fitting keras policy model
2018-08-30 07:09:37 INFO     rasa_core.agent  - Model directory models/nlu exists and contains old model files. All files will be overwritten.
2018-08-30 07:09:37 INFO     rasa_core.agent  - Persisted model to '/Users/sumit/apress_all/Chapter IV/horoscope_bot/models/nlu'
2018-08-30 07:09:37 INFO     rasa_core.training.online  - Rasa Core server is up and running on http://localhost:5005
Bot loaded. Type a message and press enter (use '/stop' to exit).
127.0.0.1 - - [2018-08-30 07:09:37] "GET /domain HTTP/1.1" 200 996 0.001847

```

现在，你可以开始和你刚出生的机器人说话了。从现在开始，你如何训练它完全掌握在你手中。每当它对不好的或意想不到的事情做出反应时，你都可以纠正它。

让我们这样做，看看它是否有所改善。

我输入“Hi”作为第一条消息，机器人返回以下内容:

```
---------------------------------------------------------------------------

Chat history:

      bot did: action_listen

      user said: hi

      whose intent is: {'confidence': 0.8472929307505297, 'name': 'greeting'}

we currently have slots: DD: None, MM: None, horoscope_sign: None, subscribe: None

------

The bot wants to [utter_greet] due to the intent. Is this correct?

      1\.      Yes
      2\.      No, intent is right but the action is wrong
      3\.      The intent is wrong
      0\.      Export current conversations as stories and quit

---------------------------------------------------------------------------

```

现在，机器人正在根据用户所说的话和他对它的理解告诉我它做了什么。现在，它也给了我们四个选择。我们一会儿会谈到这一点。

这里的 **bot_did** 是 action_listen 的意思；它只是在等待用户输入一些东西，这很好。

Bot 说出了意图*{ ' confidence ':0.8472929307505297，' name': 'greeting'}* ，这是正确的，所以我们会按 1，意思是 bot 正在理解并试图正确地做的事情。

```
1
---------------------------------------------------------------------------
Chat history:

      bot did: action_listen

      user said: hi

      whose intent is: {'confidence': 0.8472929307505297, 'name': 'greeting'}

      bot did: utter_greet

we currently have slots: DD: None, MM: None, horoscope_sign: None, subscribe: None

------
The bot wants to [action_listen]. Is this correct?

      1\.      Yes.
      2\.      No, the action is wrong.
      0\.      Export current conversations as stories and quit
---------------------------------------------------------------------------

```

你看，我们的机器人至少正确地问候了用户。如果你看到前面提到的回应，你实际上可以检查我们的机器人做了什么；在我们训练它的时候，它会记录所有这些。

```
bot did: utter_greet

```

现在，机器人说接下来的事情是等待并听用户将要说什么(即，等待用户输入)。这是正确的吗？是的，这是正确的，所以我们再次按 1，机器人给用户一个提示。

我输入，“我今天的星座是什么？”

```
---------------------------------------------------------------------------
Chat history:

      bot did: action_listen

      user said: hi

             whose intent is: {'confidence': 0.8472929307505297, 'name': 'greeting'}

      bot did: utter_greet

      bot did: action_listen

      user said: what's my horoscope for today?

      whose intent is: {'confidence': 0.8902154738608781, 'name': 'get_horoscope'}

we currently have slots: DD: None, MM: None, horoscope_sign: None, subscribe: None

------
The bot wants to [utter_ask_horoscope_sign] due to the intent. Is this correct?

      1\.      Yes
      2\.      No, intent is right but the action is wrong
      3\.      The intent is wrong
      0\.      Export current conversations as stories and quit

---------------------------------------------------------------------------

```

现在，机器人非常正确地识别出“获取星座”的意图，准确率达到 89%，这是非常好的。机器人还说它想**说出 _ ask _ 占星 _sign，**这又是正确的，因为用户还没有提到任何占星符号，槽仍然是无，如图所示。

我们再次按 1。

```
---------------------------------------------------------------------------

Chat history:

      bot did: action_listen

      user said: hi

      whose intent is: {'confidence': 0.8472929307505297, 'name': 'greeting'}

      bot did: utter_greet

      bot did: action_listen

      user said: what's my horoscope for today?

      whose intent is: {'confidence': 0.8902154738608781, 'name': 'get_horoscope'}

      bot did: utter_ask_horoscope_sign

we currently have slots: DD: None, MM: None, horoscope_sign: None, subscribe: None

------
The bot wants to [action_listen]. Is this correct?

      1\.      Yes.
      2\.      No, the action is wrong.
      0\.      Export current conversations as stories and quit

---------------------------------------------------------------------------

```

现在，机器人会询问是否到了等待用户输入的时间。是的，用户需要提供星座。

我们再次按 1，出现提示时，我们输入“摩羯”作为输入。

```
---------------------------------------------------------------------------

Chat history:

      bot did: action_listen

      user said: hi

      whose intent is: {'confidence': 0.8472929307505297, 'name': 'greeting'}

      bot did: utter_greet

      bot did: action_listen

      user said: what's my horoscope for today?

      whose intent is: {'confidence': 0.8902154738608781, 'name': 'get_horoscope'}

      bot did: utter_ask_horoscope_sign

      bot did: action_listen

      user said: Capricorn

      whose intent is: {'confidence': 0.8456705103362621, 'name': 'get_horoscope'}

      with horoscope_sign: capricorn

we currently have slots: DD: None, MM: None, horoscope_sign: capricorn, subscribe: None

The bot wants to [get_todays_horoscope] due to the intent. Is this correct?

      1\.      Yes
      2\.      No, intent is right but the action is wrong
      3\.      The intent is wrong
      0\.      Export current conversations as stories and quit

---------------------------------------------------------------------------

```

现在，正如我们所看到的，星座槽被自动设置为“**摩羯座**”

下一步是教机器人调用**get _ today _ 占星**和调用**get _ today _ 占星**动作。到目前为止，我们的槽已经为我们在占星 _ 域. yml 中定义的*占星 _ 符号*变量设置好了，所以如果再次调用这个动作，聊天机器人应该会返回当天的实际占星。让我们试试。

我输入了“摩羯座”

bot 点击动作服务器的端点，并将结果返回给用户，正如我们在自定义动作中定义的那样。

```
Your today's horoscope:

```

乐观是从失败走向成功的动力。甘尼萨说，你今天会非常乐观——对你的工作、未来和一切能让你成功的东西。在处理日常工作时，你也会非常小心，会利用每一个能让你离目标更近一步的机会。决心和好运是你实现梦想所需要的一切；今天你将两者兼得。

这似乎是公平的，因为我错过了完成这一章的最后期限，现在是早上 6 点，我还没有睡觉。尽一切努力让你的钱值得花在这本书上。

好吧，让我们回去看看我们的机器人下一步要做什么。

```
------
The bot wants to [action_listen]. Is this correct?

      1\.      Yes.
      2\.      No, the action is wrong.
      0\.      Export current conversations as stories and quit

```

也许我们不想让我们的机器人在说出今天的星座之后还在听。我们希望我们的机器人要求用户根据我们的对话脚本以及我们创建的故事订阅更新。

所以，我会按 2，它会说

```
------
what is the next action for the bot?

         0                           action_listen    1.00
         1                          action_restart    0.00
         2                 action_default_fallback    0.00
         3                             utter_greet    0.00
         4                utter_ask_horoscope_sign    0.00
         5                           utter_ask_dob    0.00
         6                         utter_subscribe    0.00
         7                    get_todays_horoscope    0.00
         8                          subscribe_user    0.00

```

因为我们希望用户订阅，所以我们应该按 6，这样机器人会询问用户是否希望订阅每日更新。

机器人回答，“你想订阅每日更新吗？”

现在机器人说:

```
---------------------------------------------------------------------------
The bot wants to [get_todays_horoscope]. Is this correct?

      1\.      Yes.
      2\.      No, the action is wrong.
      0\.      Export current conversations as stories and quit

```

这里的动作不正确，所以我们按 2，训练机器人听用户这里的动作。

```
---------------------------------------------------------------------------
what is the next action for the bot?

         0                           action_listen    0.21
         1                          action_restart    0.01
         2                 action_default_fallback    0.01
         3                             utter_greet    0.21
         4                utter_ask_horoscope_sign    0.51
         5                           utter_ask_dob    0.01
         6                         utter_subscribe    0.02
         7                    get_todays_horoscope    0.78
         8                          subscribe_user    0.22
---------------------------------------------------------------------------

```

当机器人等待知道正确的下一步时，我们按 0。机器人现在将在我们的交互式学习过程中等待用户输入。

用户在这里说，“请订阅我，”我们的机器人以 80%的信心成功地识别出这是一个订阅意图，并且根据我们在 data.json 中的训练数据，很容易理解用户是在请求订阅而不是取消订阅。换句话说，它将 subscribe 的槽设置为 True，如下所示:

```
---------------------------------------------------------------------------

      user said: Please subscribe me

      whose intent is: {'confidence': 0.795172441763619, 'name': 'subscription'}

      with subscribe: True

we currently have slots: DD: None, MM: None, horoscope_sign: capricorn, subscribe: True
---------------------------------------------------------------------------

```

现在，我们的机器人已经理解了它的意图，并解析了其中的实体，是时候回复用户说“他已经成功订阅了”，然后我们从机器人那里得到一条消息:

```
You're successfully subscribed

```

这就对了。你完全可以自己成功构建自己的室内聊天机器人。作为练习的一部分，我建议你添加我们讨论过的星座机器人的所有用例，看看它是否有效。当我们到目前为止所做的一切都运行良好时，尝试添加更多的用例和更多的功能。

您可以在这里添加更多的话语信息，以便机器人在对话完成后说，“再见，祝您愉快”。我坚信你应该有能力做到这一点。一定要这样做，并让我们知道你的进展如何。

现在，最后一部分是将所有这些学习反馈给用户，这样我们就不必再次教授相同的故事，机器人会尝试从现有的故事和未来的故事中学习。

### 将对话导出为故事

现在，互动学习部分的下一步是按 0，将我们当前的对话导出为故事，然后退出。

为此，我们按 0，机器人会提示如下内容:

```
File to export to (if file exists, this will append the stories) [stories.md]:

```

只需输入我们的 **stories.md** 文件名，如果您保留了任何其他名称，请确保您给出了正确的文件名。

Rasa 为我们完成了这项艰巨的工作，并自动生成了一个 stories.md 文件，如下所示:

```
## Generated Story 3797421409943253925
* greeting
    - utter_greet
* I want to know my horoscope
    - utter_ask_horoscope_sign
* get_horoscope

## Generated Story 7304374603374920907
* greeting
    - utter_greet
* what is my todays horoscope?
    - utter_ask_horoscope_sign
* Cancer

## Generated Story -6877464862083507836
* greeting
    - utter_greet
* get_horoscope
    - utter_ask_horoscope_sign
* get_horoscope{"horoscope_sign": "capricorn"}
    - slot{"horoscope_sign": "capricorn"}
    - get_todays_horoscope
    - slot{"horoscope_sign": "capricorn"}
    - utter_subscribe
* subscription{"subscribe": "True"}
    - slot{"subscribe": "True"}
    - subscribe_user
    - slot{"subscribe": true}

```

您可以在使用上述文件训练模型时更改 stories 文件的源，也可以将新生成的故事复制并粘贴到我们的原始 stories.md 文件中。现在，我将把这些故事复制并粘贴到我们原来的 stories.md 文件中。在再次测试或进行交互式学习之前，请确保再次运行您的模型。

## 测试机器人

测试机器人是我们互动学习过程的一部分。我们不断检查最初为机器人想到的所有可能的场景，并相应地训练它。我测试了一些其他场景的星座机器人，并对其进行了相应的训练。下面是其中一个与我们在本章前面所做的有点不同的例子。

### 测试案例 1

让我们运行第一个测试:

*   用户:你好！

*   **星座机器人:**你好！能为你做什么？

*   **用户:**摩羯座今天的星座是什么？

*   **星座机器人:**你今天的星座:

乐观是从失败走向成功的动力。甘尼萨说，你今天会非常乐观——对你的工作、未来和一切能让你成功的东西。在处理日常工作时，你也会非常小心，会利用每一个能让你离目标更近一步的机会。决心和好运是你实现梦想所需要的一切；今天你将两者兼得。

*   **星座机器人:**要订阅每日更新吗？

*   **用户:**请订阅我。

*   **星座机器人:**您已成功订阅。

正如你在用户和聊天机器人之间的对话中看到的，我们测试了机器人是否处理用户自己提供星座运势同时询问当天星座运势的场景。在这种情况下，机器人做得很好，并最终要求订阅，并根据用户的响应，采取适当的行动。

您应该对机器人的对话进行健全性测试，以确定正常流是否正常工作。

我还测试了我们在 stories.md 文件中提到的故事，当用户直接要求订阅时，它也工作正常。

### 测试案例 2

现在是第二个测试:

*   **用户:**嗨

*   **星座机器人:**你好！能为你做什么？

*   **用户:**请为我订阅每日更新。

*   **星座机器人:**您已成功订阅。

我还会添加一些新的故事，这样机器人就可以完美地工作了。但是现在我们有了一个完全正常工作的机器人。在 github 的第二个版本中，你还会发现这个机器人正在纠正星座的拼写错误，根据用户的出生日期检索星座，说再见信息，等等。我强烈建议您检查代码，看看它是如何完成的，并提供您的反馈。但在此之前，考虑一下将如何完成以及变化将会发生在哪里。我们故意没有在本章中提到其他用例的代码，这样当你集中精力学习交易技巧时，它不会变得繁琐。

您可以从我们的 github repo 下载最新的 Python 代码和 Jupyter 笔记本，并尝试安装正确的包来运行它。你会发现在本章讨论的代码中处理了更多的用例。

## 摘要

在这一章中，我们了解了 Rasa-NLU，以及为什么 Rasa-NLU 比市场上任何其他开源工具都好。我们学习了如何在管道配置中使用 tensorflow、sklearn 和 keras 来配置管道。

我们学会了在本地系统上从头开始创建一切，而不依赖于任何需要您使用其 API 的服务，如 Dialogflow、wit.ai 等。

我们还学习了如何创建故事，以及如何训练 NLU 模型和对话模型，并使用 Rasa Core 通过使用最酷的功能交互式学习进行训练来构建机器人。在开源工具如 rasa-nlu-trainer 的帮助下，我们也对如何轻松地创建训练数据并轻松地进行注释有了一个相当好的想法。我希望这一章对你来说比其他任何一章都更具互动性。如果你没有成就感，那就为下一章做好准备，在那里我们将把它真实地呈现给我们的观众，并向世界展示机器人的能力。我们将学习使用我们自己的网络服务器把本章的聊天机器人集成到各种平台上，比如脸书和 Slack。

继续训练你的机器人，直到下一章我们把它投入使用。

下一章见。**